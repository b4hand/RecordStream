#!/usr/bin/perl -w

$| = 1;

use strict;
use warnings;

my @ACTIONS = (
   Recs::Shell::Quit->new(),
   Recs::Shell::Help->new(),
   Recs::Shell::Generate->new(),
   Recs::Shell::ShowStreams->new(),
   Recs::Shell::Transform->new(),
   Recs::Shell::HistoryUp->new(),
   Recs::Shell::HistoryDown->new(),
   Recs::Shell::ShowHistory->new(),
   Recs::Shell::Print->new(),
);

main(\@ARGV);

sub main {
   my $args = shift;

   my $status = Recs::Shell::Status->new(
      DIR => $HOME . '/.recs-shell';
   );
   shell_loop($status);
}

sub shell_loop {
   my $status = shift;
   while ( 1 ) {
      print "> ";
      my $input = <STDIN>;
      if ( ! defined $input ) {
         exit 0;
      }

      chomp $input;
      my ($action, $line_args) = find_action($input);

      if ( $action ) {
         eval {
            my $new_status = $action->run($status, $line_args);

            if ( $new_status ) {
               $status = $new_status;
            }
         };

         if ( $@ ) {
            warn "Operation failed!: $@";
            warn "Type 'q' to quit, 'h' for help\n";
         }
      }
      else {
         print "Could not find action for input!\n";
         print "See 'help' for help on accepted commands\n";
         next;
      }
   }
}

sub find_action {
   my $line = shift;
   my ($possible_action, $line_info) = $line =~ m/^([^ ]*) *(.*)$/;
   return if (! defined $possible_action );

   foreach my $action (@ACTIONS) {
      my $names = $action->action_names();
      if ( grep { $possible_action eq $_ } @$names ) {
         return ($action, $line_info);
      }
   }

   return;
}

package Recs::Shell::Base;

use strict;
use warnings;

sub new {
   my $class = shift;
   my $line  = shift;

   my $this = {
   };

   bless $this, $class;

   $this->init();
   return $this;
}

sub init {
}

sub run {
   my $this = shift;
   die "Subclass should override run! in subclass: " . ref($this);
}

package Recs::Shell::Help;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub help {
   return 'This help screen';
}

sub action_names {
   return [qw(h help)];
}

sub run {
   my $this   = shift;
   my $status = shift;

   my $max_length = 0;
   foreach my $action (@ACTIONS) {
      my $names = join(', ', @{$action->action_names()});
      my $new_length = length($names) + 2;
      if ( $max_length < $new_length ) {
         $max_length = $new_length;
      }
   }

   foreach my $action (@ACTIONS) {
      my $names = join(', ', @{$action->action_names()});
      my $length = length($names);

      print $names;
      print ' ' x ($max_length - $length);
      print '- ' . $action->help() . "\n";
   }

   return $status;
}

1;

package Recs::Shell::Print;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(p print)];
}

sub help {
   return 'Show current master stream (or specified stream)';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   my $streams = $status->get_streams();

   my $index = $status->get_master_stream_index();
   if ( $line =~ m/^\d+$/ ) {
      $index = $line - 1;
   }
   elsif ( $line ) {
      die "Argument to showstreams must be numeric!\n";
   }

   my $stream  = $streams->[$index];
   my $command = $stream->get_command();
   print "Output for $command:\n";
   my $output = $stream->print_output(\*STDOUT);

   return $status;
}

1;

package Recs::Shell::ShowStreams;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(ss showstreams)];
}

sub help {
   return 'Show all streams in the system, specify a stream number to see its output';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   my $streams = $status->get_streams();

   if ( ! $line ) {
      print "Current streams: (* - Indicates current master stream)\n";
      my $master_index = $status->get_master_stream_index();
      my $count = 0;
      foreach my $stream (@$streams) {
         my $master_char = ' ';
         $master_char = '*' if ( $count == $master_index );
         $count++;
         my $command = $stream->get_command();
         #TODO: space $count for justification
         print "$master_char $count - $command\n";
      }
   }
   elsif ( $line =~ m/^\d+$/ ) {
      my $stream  = $streams->[$line-1];
      my $command = $stream->get_command();
      print "Output for $command:\n";
      my $output = $stream->print_output(\*STDOUT);
   }
   else {
      die "Argument to showstreams must be numeric!\n";
   }

   return $status;
}

1;

package Recs::Shell::Transform;

use strict;
use warnings;

use IPC::Open2 qw(open2);
use POSIX qw(_exit);

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(t transform xform)];
}

sub help {
   return 'Transform the master stream with a command';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   my $stream = $status->get_master_stream();

   my ($outh, $inh);

   my $transform_pid = open2($outh, $inh, $line) or die "Could not fork: $line:$!";

   my $pid = fork();

   if ( $pid ) {
      my $output;
      close $inh;
      while(my $line = <$outh>) {
         $output .= $line;
         print $line;
      }
      waitpid $pid, 0;
      waitpid $transform_pid, 0;

      my $new_status = $status->add_child($line, $output);
      return $new_status;
   }
   elsif ( $pid == 0 ) {
      close $outh;
      $stream->print_output($inh);
      close $inh;
      # Do not invoke END handlers
      exit(0);
   }
   else {
      die "Could not fork: $!";
   }
}

1;

package Recs::Shell::Generate;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(g generate)];
}

sub help {
   return 'generate a new input stream';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   print "Running $line\n";
   open(my $fh, '-|', $line) or die "Could not fork $line:$!";

   my $output;
   while ( my $line = <$fh> ) {
      $output .= $line;
      print $line;
   }

   close $fh;

   $status->add_new_stream($line, $output);

   return $status;
}

1;

package Recs::Shell::Quit;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(q quit)];
}

sub help {
   return 'Exit the program';
}

sub run {
   print "Quitting\n";
   exit 0;
}

1;

package Recs::Shell::ShowHistory;

use strict;
use warnings;

use base qw(Recs::Shell::Base);


sub action_names {
   return [qw(sh showhistory)];
}

sub help {
   return 'Show history tree';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   my $root = $status;
   while ($root->get_parent()) {
      $root = $root->get_parent();
   }

   print "History Tree: (* Indicates master or default child)\n";
   print determine_title($root, $status) . "\n";
   print_children($root, '  ', $status);
}


sub determine_title {
   my $current     = shift;
   my $here_status = shift;

   my $HERE_MARK = '**YOU ARE HERE**';

   my $title = $current->get_title();

   if ( $current == $here_status ) {
      $title .= ' ' . $HERE_MARK;
   }

   return $title;
}

sub print_children {
   my $status      = shift;
   my $prefix      = shift;
   my $here_status = shift;

   my $master_index = $status->get_master_child_index();
   my $index = 0;
   foreach my $child (@{$status->get_children()}) {
      my $title = determine_title($child, $here_status);
      my $display_index = $index +1;

      my $separator = ' ';
      if ( $index == $master_index ) {
         $separator = '*';
      }

      print "$prefix$separator$display_index - $title\n";
      print_children($child, "$prefix  ", $here_status);
      $index++;
   }
}

1;

package Recs::Shell::HistoryUp;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(u up)];
}

sub help {
   return 'Go "up" in the history tree';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   my $new = $status->get_parent();
   if ( ! $new ) {
      print "Cannot go up, you are at root!\n";
      return $status;
   }
   else {
      return $new;
   }
}

1;

package Recs::Shell::HistoryDown;

use strict;
use warnings;

use base qw(Recs::Shell::Base);

sub action_names {
   return [qw(d down)];
}

sub help {
   return 'Go "down" in the history tree, argument specifies which branch to descend to';
}

sub run {
   my $this   = shift;
   my $status = shift;
   my $line   = shift;

   my $index = $status->get_master_child_index();
   if ( $line =~ m/^\d$/ ) {
      $index = $line - 1;
   }
   elsif ( $line ) {
      die "Argument to down isn't numeric, bailing!\n";
   }

   if ( my $new = $status->get_child($index) ) {
      $status->set_master_child_index($index);
      return $new;
   }
   else {
      if ( $line ) {
         print "Cannot go down, no child at index: $line\n";
      }
      else {
         print "Cannot go down, you are at the lowest level!\n";
      }

      return $status;
   }
}

1;

package Recs::Shell::Status;

use strict;
use warnings;

sub new {
   my $class    = shift;
   my %args     = (@_);
   my $parent   = $args{'PARENT'};
   my $children = $args{'CHILDREN'} || [];
   my $streams  = $args{'STREAMS'}  || [];
   my $dir      = $args{'DIR'};

   my $master_index = -1;
   if ( $streams ) {
      $master_index = (scalar @$streams) - 1;
   }
   else {
      $streams = [];
   }

   my $child_index = -1;
   if ( ! $children ) {
      $children = [];
   }
   else {
      $child_index = (scalar @$children) - 1;
   }

   if ( (! $dir) && $parent ) {
      $dir = $parent->get_dir();
   }

   my $this = {
      STREAMS             => $streams,
      PARENT              => $parent,
      CHILDREN            => $children,
      MASTER_STREAM_INDEX => $master_index,
      MASTER_CHILD_INDEX  => $child_index,
      DIR                 => $dir,
   };

   bless $this, $class;
   return $this;
}

sub get_dir {
   my $this = shift;
   return $this->{'DIR'};
}

sub get_parent {
   my $this = shift;
   return $this->{'PARENT'};
}

sub get_title {
   my $this = shift;
   if ( my $parent = $this->get_parent() ) {
      return $this->get_master_stream()->get_command();
   }

   return 'root';
}

sub get_children {
   my $this = shift;
   return $this->{'CHILDREN'};
}

sub get_master_child {
   my $this = shift;
   return $this->get_child($this->get_master_child_index());
}

sub get_master_child_index {
   my $this = shift;
   return $this->{'MASTER_CHILD_INDEX'};
}

sub set_master_child_index {
   my $this  = shift;
   my $index = shift;
   $this->{'MASTER_CHILD_INDEX'} = $index;
}

sub get_child {
   my $this  = shift;
   my $index = shift;
   return $this->{'CHILDREN'}->[$index];
}

sub get_master_stream {
   my $this = shift;
   return $this->{'STREAMS'}->[$this->{'MASTER_STREAM_INDEX'}];
}

sub add_new_stream {
   my $this    = shift;
   my $command = shift;
   my $output  = shift;

   my $stream = Recs::Shell::Stream->new($command, $output);

   push @{$this->{'STREAMS'}}, $stream;
   $this->set_master_stream_index((scalar @{$this->{'STREAMS'}}) -1 );
}

sub set_master_stream_index {
   my $this       = shift;
   my $new_master = shift;
   $this->{'MASTER_STREAM_INDEX'} = $new_master;
}

sub get_master_stream_index {
   my $this       = shift;
   return $this->{'MASTER_STREAM_INDEX'};
}

sub get_streams {
   my $this = shift;
   return $this->{'STREAMS'};
}

sub add_child {
   my $this    = shift;
   my $command = shift;
   my $output  = shift;

   my $master_index = $this->get_master_stream_index();
   my $streams = $this->get_streams();
   my $new_streams = [];

   my $index = 0;
   foreach my $stream (@$streams) {
      if ( $index != $master_index ) {
         push @$new_streams, $stream;
      }
      $index++;
   }

   my $new_status = Recs::Shell::Status->new(
      PARENT  => $this,
      STREAMS => $new_streams,
   );

   $new_status->add_new_stream($command, $output);

   push @{$this->{'CHILDREN'}}, $new_status;
   $this->set_master_child_index((scalar @{$this->{'CHILDREN'}}) - 1);

   return $new_status;
}

1;

package Recs::Shell::Stream;

use strict;
use warnings;

sub new {
   my $class   = shift;
   my $command = shift;
   my $output  = shift;
   
   my $this = {
      COMMAND => $command,
      OUTPUT  => $output,
   };

   bless $this, $class;
   return $this;
}

sub master {
   my $this = shift;
   return $this->{'MASTER'};
}

sub get_command {
   my $this = shift;
   return $this->{'COMMAND'};
}

sub get_output {
   my $this = shift;
   return $this->{'OUTPUT'};
}

sub print_output {
   my $this = shift;
   my $fh   = shift;

   print $fh $this->get_output();
}

1;

package Recs::Shell::HumanReadableStorable;

use strict;
use warnings;

use Data::Dumper;

sub write_data {
   my $file = shift;
   my $data = shift;

   open(my $fh, '>', $file) or die "Could not open $file: $!";
   print $fh Data::Dumper::Dumper($data);
   close $fh;
}

sub read_data {
   my $file = shift;

   open(my $fh, '<', $file) or die "Could not open $file: $!";
   local $/;
   my $contents = <$fh>;
   close $fh;

   my $VAR1;
   eval($contents);

   if ( $@ ) {
      die "Failed reading $file: $@";
   }

   return $VAR1;
}

1;
